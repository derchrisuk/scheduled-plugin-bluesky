#!/usr/bin/python

import re
import time
import json
import urllib3
import requests
import pytz
import traceback
import time
import sys
from os.path import isfile, join
from os import remove, walk, environ
from datetime import datetime, timedelta, date
from urlparse import urlparse

from hosted import config

session = requests.Session()
headers = {
    'User-Agent': 'info-beamer bluesky poller serial {}'.format(environ.get('SERIAL', 'unknown')),
    'Accept': 'application/json'
}

def cache_image(url):
    if not url:
        return None
    image_url = urlparse(url)
    image_filename = image_url.path.split('/')[-1]
    if not image_filename:
        image_filename = url.split('/')[-1]
    if not isfile(image_filename):
        try:
            with open(image_filename, 'wb') as f:
                r = session.get(url)
                r.raise_for_status()
                f.write(r.content)
        except Exception as e:
            sys.stderr.write("[bluesky] exception while caching image {} - {}\n".format(url, e))
            return None
    return image_filename

class BlueskyPost:
    def __init__(self, post):
        self.post = post
        self.profile_image = None
        self.attachment_image = None

    def _log(self, text):
        sys.stderr.write("[bluesky] [post {}] {}\n".format(self, text))

    def __str__(self):
        return self.post.get('cid', 'unknown')

    def cache_images(self):
        # Cache profile avatar
        avatar_url = self.post.get('author', {}).get('avatar', '')
        if avatar_url:
            self.profile_image = cache_image(avatar_url)
        
        # Cache media attachments
        embed = self.post.get('embed', {})
        embed_type = embed.get('$type', '')
        
        if embed_type == 'app.bsky.embed.images#view':
            images = embed.get('images', [])
            if images:
                # Get the first image
                image = images[0]
                # Use fullsize image, but check dimensions if available
                image_url = image.get('fullsize', '')
                if image_url:
                    self.attachment_image = cache_image(image_url)
        
        elif embed_type == 'app.bsky.embed.external#view':
            external = embed.get('external', {})
            thumb_url = external.get('thumb', '')
            if thumb_url:
                self.attachment_image = cache_image(thumb_url)

    @property
    def text(self):
        # Bluesky text is plain text, but we still clean it up
        string = self.post.get('record', {}).get('text', '')
        # Remove excessive whitespace
        string = re.sub(r'\s+', ' ', string)
        return string.strip()

    @property
    def account_name(self):
        return self.post.get('author', {}).get('handle', 'unknown.bsky.social')

    @property
    def is_from_blocked_account(self):
        try:
            blocked = {}
            with open('blocked.txt') as f:
                for line in f.read().strip().splitlines():
                    line = line.strip()
                    if '#' in line:
                        acct, reason = line.split('#', 1)
                    else:
                        acct, reason = line, 'unknown'
                    blocked[acct.strip()] = reason.strip()
            for acct in config.filter_accounts.split(','):
                blocked[acct.strip()] = 'specified manually'
            if self.account_name in blocked:
                self._log("account is blocked: {}".format(blocked[self.account_name]))
                return True
        except Exception as e:
            self._log("Exception while checking for blocked accounts: {}".format(repr(e)))
        return False

    @property
    def created_timestamp(self):
        created_at = self.post.get('record', {}).get('createdAt', '')
        if not created_at:
            return int(time.time())
        
        try:
            # Bluesky uses ISO 8601 format with timezone
            # Example: 2024-01-01T12:00:00.000Z
            if created_at.endswith('Z'):
                date_time_obj = datetime.strptime(created_at, '%Y-%m-%dT%H:%M:%S.%fZ')
            else:
                # Handle other timezone formats if needed
                date_time_obj = datetime.strptime(created_at.split('+')[0].split('.')[0], '%Y-%m-%dT%H:%M:%S')
            return int(time.mktime(date_time_obj.timetuple()))
        except Exception as e:
            self._log("Error parsing timestamp {}: {}".format(created_at, e))
            return int(time.time())

    @property
    def ignore_post(self):
        text = self.post.get('record', {}).get('text', '')
        
        if not text:
            self._log("Garbage: no content")
            return True
        
        if config.filter_garbage and ('@twitter.com' in text or "x.com/" in text or 'nitter.net/' in text):
            self._log("Filtered: mentions Twitter/X")
            return True
        
        if self.is_from_blocked_account:
            self._log("Filtered: from blocked account")
            return True
        
        return False


class BlueskyFetcher:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers = {
            'User-Agent': 'info-beamer bluesky poller serial {}'.format(environ.get('SERIAL', 'unknown')),
            'Accept': 'application/json'
        }
        # Handle missing not_before config with a sensible default
        not_before_str = getattr(config, 'not_before', '2024-01-01')
        self.not_before = int(time.mktime(datetime.strptime(not_before_str, "%Y-%m-%d").timetuple()))
        self.posts = []
        self.access_token = None
        self.auth_expires = 0

    def _log(self, something, tag=None):
        if not isinstance(something, str):
            something = repr(something)
        if tag is not None:
            something = "[#{}] {}".format(tag, something)
        sys.stderr.write("[bluesky] {}\n".format(something))

    def authenticate(self):
        """Authenticate with Bluesky and get access token"""
        # Check if we have valid credentials in config
        if not hasattr(config, 'bluesky_handle') or not hasattr(config, 'bluesky_app_password'):
            self._log("ERROR: bluesky_handle and bluesky_app_password must be configured!")
            raise Exception("Missing Bluesky credentials in config")
        
        # Check if we already have a valid token
        if self.access_token and time.time() < self.auth_expires:
            self._log("using existing valid access token")
            return self.access_token
        
        self._log("authenticating with Bluesky...")
        
        auth_url = "https://bsky.social/xrpc/com.atproto.server.createSession"
        auth_data = {
            'identifier': config.bluesky_handle,
            'password': config.bluesky_app_password
        }
        
        try:
            r = self.session.post(auth_url, json=auth_data)
            self._log("auth response status: {}".format(r.status_code))
            r.raise_for_status()
            
            auth_response = r.json()
            self.access_token = auth_response.get('accessJwt')
            
            # Tokens typically last 2 hours, refresh after 1.5 hours to be safe
            self.auth_expires = time.time() + (90 * 60)
            
            self._log("authentication successful!")
            return self.access_token
            
        except Exception as e:
            self._log("authentication failed: {}".format(e))
            raise

    def _fetch(self, tag):
        self._log("starting _fetch()", tag=tag)
        
        # Ensure we're authenticated
        self.authenticate()
        
        # Use authenticated endpoint (bsky.social, not public.api.bsky.app)
        url = "https://bsky.social/xrpc/app.bsky.feed.searchPosts"
        
        params = {
            'q': '{}'.format(tag),  # Do not Include # symbol in query
            'limit': min(int(config.count), 100),  # Max 100 posts
            'sort': 'latest'  # Get most recent posts
        }
        
        # Add authorization header
        headers = {
            'Authorization': 'Bearer {}'.format(self.access_token)
        }
        
        self._log("fetching with params: {}".format(params), tag=tag)
        
        r = self.session.get(url, params=params, headers=headers)
        self._log("http status code was {}".format(r.status_code), tag=tag)
        
        r.raise_for_status()
        
        response_data = r.json()
        posts = response_data.get('posts', [])
        self._log("fetched {} posts".format(len(posts)), tag=tag)
        
        return posts

    def fetch_and_parse(self, tag):
        try:
            # Remove # prefix if present
            tag = tag.lstrip('#')
            
            posts = self._fetch(tag)
            for post_data in posts:
                post = BlueskyPost(post_data)
                
                # Check for duplicates by CID
                if any(p.post.get('cid') == post.post.get('cid') for p in self.posts):
                    self._log("ignoring {} because duplicate".format(post), tag=tag)
                    continue
                
                if post.ignore_post:
                    # reason already printed by BlueskyPost
                    continue
                
                if post.created_timestamp < self.not_before:
                    self._log("ignoring {} because it was created too long ago (is {}, want {})".format(
                        post, post.created_timestamp, self.not_before), tag=tag)
                    continue
                
                self.posts.append(post)
        except Exception as e:
            self._log("Exception during fetch_and_parse: {}".format(e), tag=tag)
            traceback.print_exc()

    def cache_and_cleanup_images(self):
        images = {
            'bluesky-logo.png',
            'node.png',
            'package.png',
            'package-header.jpg'
        }
        to_delete = set()
        for post in self.posts:
            post.cache_images()
            for path in (post.profile_image, post.attachment_image):
                if path is not None:
                    images.add(path)
        for root, dirs, files in walk('./'):
            for name in files:
                if (
                    name.endswith('png')
                    or name.endswith('jpg')
                    or name.endswith('jpeg')
                    or name.endswith('gif')
                ) and name not in images:
                    to_delete.add(name)
        for path in to_delete:
            self._log("deleting image {} because it's not used anywhere".format(path))
            remove(path)

    def dump_json(self):
        out = []
        for post in self.posts:
            display_name = post.post.get('author', {}).get('displayName', '')
            if not display_name:
                display_name = post.account_name
            
            out.append({
                'created_at': post.created_timestamp,
                'content': post.text,
                'account': {
                    'acct': post.account_name,
                    'display_name': display_name,
                    'avatar_static': post.profile_image,
                },
                'media_attachment': post.attachment_image or '',
            })
        
        self._log("have gotten {} posts in total".format(len(out)))
        if len(out) > 0:
            with open('postlist.json', 'wb') as f:
                f.write(json.dumps(out, ensure_ascii=False).encode('utf8'))
            self._log("wrote {} posts to postlist.json".format(len(out)))


def main():
    config.restart_on_update()

    if config.poll_interval == 0:
        print >>sys.stderr, "waiting for a config change"
        while 1:
            time.sleep(100000)

    while 1:
        try:
            poller = BlueskyFetcher()
            for tag in config.tag.split(','):
                poller.fetch_and_parse(tag.strip())
            poller.cache_and_cleanup_images()
            poller.dump_json()
        except:
            traceback.print_exc()
            time.sleep(60)
        else:
            time.sleep(60 * config.poll_interval)

if __name__ == "__main__":
    main()
